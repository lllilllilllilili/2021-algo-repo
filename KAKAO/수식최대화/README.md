## 수식최대화 문제 설명

| 접근 : 분할탐색 (작은것으로 큰걸 만든다.)

| 종류 : 재귀에 대한 이해, 분할탐색 개념

| 구현 :

**step1)** : \*, -, + 3개의 연산자를 사용하기 때문에 각 케이스에 대한 재귀 탐색 함수를 생성한다.

**step2)** : *, -, + 에 대해서 각 `split` 기준을 각 연산자로 잡고 재귀 탐색을 진행한다. (예를들어 *에 대해 split 했다면 다음 재귀는 step1 에서 만들어둔 \*, -, + 순서에 맞춰서 연산자의 케이스를 살펴보면 된다.)

**step3** : 최종적으로 2번의 `depth`를 타게 되면 더이상 갈 수 없게 되므로 해당 연산자의 값을 계산하고 반환해준다.(기저조건)
그리고 마지막으로 반환받는 값에 따라 최솟값을 갱신해주면 된다.

| 시간 복잡도 : O(N) (expression의 길이가 최대 100)

| 메모리 사용량 : 문자열 사용한것 외에는 크게 사용한것이 없다. parse 할때 메모리를 사용하는 케이스가 되는지는 확실하지 않다.

| 엣지 케이스 : 없을것 같다. 오히려 구현이라 단순했던 문제

| 더 좋은 방법 : 분할탐색이 자칫 일반 재귀랑 착각할 수 있을정도로 유사하지만 개념적으로 아는지 모르는지에 따라서 문제 접근 시각이 달라질 수 있으니 분할탐색에 대해 이번 기회에 이해했으면 바람
